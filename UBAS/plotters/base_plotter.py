"""
base_plotter.py
===============
Base class for plotters to subclass from
"""

import matplotlib.pyplot as plt
import os
import seaborn as sns
import pandas as pd
import numpy as np


class BasePlotter:
    """Base class for plotters"""
    def __init__(self, filename="", plotting_interval=5, plots=["scatter_matrix", "pred_vs_actual"],
                 input_names=None, target_name=None, save_type="png", *args, **kwargs):
        """
        Class Initialization

        Parameters
        ----------
        filename : str default=""
            The directory in which to save the plots generated by the associated sampler
        plotting_interval : int default=5
            Plots are generated and saved every `plotting_interval` iterations
        plots : list[str], Default=["scatter_matrix", "pred_vs_actual"]
            A list of strings corresponding to the plots that should be generated. Currently supported plots are:
            "scatter_matrix" and "pred_vs_actual"
        input_names : list[str] default=None
            The variable names of each input to be displayed on the plots. If None, x1, x2, ... are used.
        target_name : str
            The variable name of the output to be displayed on the plots. If None, x_{n+1} is used
        save_type : str default=".png"
            The figure file extension.
        *args
            Extra arguments to the plotter should be passed as keyword arguments
        **kwargs
            Extra keyword arguments to the plotting function
        """

        self.supported_graphs = {"scatter_matrix": BasePlotter.scatter_matrix,
                                 "pred_vs_actual": BasePlotter.pred_vs_actual}
        self.filename = filename
        self.plotting_interval = plotting_interval
        self.plots = plots
        self.input_names = input_names
        self.target_name = target_name
        self.save_type = save_type
        self.plotting_params = kwargs

    def generate_plots(self, iteration, x, x_new, y_preds, y_bounds, y_exact, y_new_exact, **plot_kwargs):
        """
        The class responsible for generating the desired plots at each plotting interval

        Parameters
        ----------
        iteration : int
            The sampling iteration, used for the filename.
        x : NDArray
            The x-values to be plotted, including those just recently sampled
        x_new : NDArray
            The x-values sampled from the most recent sampling iteration
        y_preds : NDArray
            The predicted y-values associated with the given x-values
        y_bounds : NDArray
            The predicted bounds associated with the given x-values
        y_exact : NDArray default
            The exact y-values that have been sampled, including those just recently sampled.
        y_new_exact : NDArray default
            The exact y-values corresponding to the x-values sampled from the most recent sampling iteration.
        """
        for plot in self.plots:
            plot_path = os.path.join(self.filename, "plots", plot + f"_iter_{iteration}." + self.save_type)
            data_path = os.path.join(self.filename, "plots", "data", plot, f"iter_{iteration}" + ".json")
            os.makedirs(os.path.join(self.filename, "plots"), exist_ok=True)
            os.makedirs(os.path.join(self.filename, "plots", "data", plot), exist_ok=True)

            # Convert to DataFrames
            x_df = pd.DataFrame(x)
            x_new_df = pd.DataFrame(x_new)

            if self.input_names is not None:
                x_df.columns = self.input_names
                x_new_df.columns = self.input_names

            x_df = pd.concat([x_df.assign(Sample_Delimiters='Full Training Set'),
                              x_new_df.assign(Sample_Delimiters='New Training Points')], ignore_index=True)

            y_df = pd.DataFrame(np.c_[y_preds, y_bounds, y_bounds[:, 1] - y_bounds[:, 0]])
            y_df = pd.concat([y_df, y_df.tail(x_new.shape[0])], ignore_index=True)
            y_df = pd.concat([y_df, pd.DataFrame(np.append(y_exact, y_new_exact))], axis=1)

            y_variable_name = self.target_name if self.target_name is not None else "Y"
            y_df.columns = [y_variable_name + " Predictions", "Lower Bound", "Upper Bound",
                            "Width", "Exact " + y_variable_name]

            plot = self.supported_graphs[plot](plot_path, data_path, x_df, y_df, **plot_kwargs)

    @staticmethod
    def scatter_matrix(plot_path, data_path, x_df, y_df, *args, **kwargs):
        """
        A plotting method to generate and save a scatter_matrix (also known as pairwise plot) using the seaborn
        interface.

        Parameters
        ----------
        plot_path : str
            The path where to save the file, including the filename and file extension.
        data_path : str
            The path where to save the data used to make the graph, including the .json extension
        x_df : DataFrame
            A DataFrame containing all the sampled input values
        y_df : DataFrame
            A DataFrame containing all the y-predictions, the y-bounds, and the new y-values
        *args
            Extra arguments should be passed as keyword arguments
        **kwargs
            Extra keyword arguments to the pairplot function of sns
        """
        use_seaborn = kwargs.pop("use_seaborn", None)
        samples = kwargs.pop('samples', None)

        colormap = np.array([plt.cm.tab10.colors[0], plt.cm.tab10.colors[1]])
        alphas = np.array([0.2, 1])
        markers = np.array(["o", "s"])

        pairwise_array = pd.concat([x_df.iloc[:, :-1], y_df[["Width", np.array(y_df.columns)[-1]]],
                                    x_df.iloc[:, -1]], axis=1)

        dimension = len(pairwise_array.columns) - 1
        plt.ioff()
        fig, ax = plt.subplots(dimension, dimension, figsize=(dimension * 2, dimension * 2))
        if samples is None:
            plot_array = pairwise_array
        else:
            plot_array = pairwise_array.sample(samples).sort_index()

        if use_seaborn is not None:
            plot = sns.pairplot(plot_array, hue='Sample_Delimiters', markers=["o", "s"], diag_kind='hist', **kwargs)
        else:
            plot = pd.plotting.scatter_matrix(plot_array.iloc[:, :-1], ax=ax,
                                        c=colormap[plot_array["Sample_Delimiters"].astype("category").cat.codes],
                                        alpha=alphas[plot_array["Sample_Delimiters"].astype("category").cat.codes],
                                        range_padding=0.25, edgecolors='white', s=70, hist_kwds={"color": colormap[0],
                                                                                                 "edgecolor": "black"})

        json = pairwise_array.to_json(orient='split', compression='infer')

        with open(data_path, 'w') as f:
            f.write(json)

        plt.savefig(plot_path)
        plt.ion()

    @staticmethod
    def pred_vs_actual(plot_path, data_path, x_df, y_df, *args, **kwargs):
        """
        A plotting method to generate and save a predicted_vs_actual_plot using the seaborn interface

        Parameters
        ----------
        plot_path : str
            The path where to save the file, including the filename and file extension.
        data_path : str
            The path where to save the data used to make the graph, including the .json extension
        x_df : DataFrame
            A DataFrame containing all the sampled input values
        y_df : DataFrame
            A DataFrame containing all the y-predictions, the y-bounds, and the new y-values
        *args
            Extra arguments should be passed as keyword arguments
        **kwargs
            Extra keyword arguments to the pairplot function of sns
        """
        pass



